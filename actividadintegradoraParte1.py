# -*- coding: utf-8 -*-
"""ActividadIntegradora.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15JNQv-PQPilEr1_ub-p-4eJH_IPpPG24
"""

#Omar Pérez González A01383853 Instituto Tecnológico y de Estudios Superiores de Monterrey

!pip3 install mesa

from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import SimultaneousActivation
from mesa.datacollection import DataCollector

%matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"]="jshtml"
matplotlib.rcParams['animation.embed_limit']=2**128

import numpy as np
import pandas as pd
import random

import time
import datetime

#Variables que ayudan al funcionamiento del modelo
exPila=False
contCajas=0
cajas_en_Pila=0
movimientosRobot=0

#Función que regresa la habitación o almacén
def obtener_habitacion(modelo):
  habitacion = np.zeros((modelo.grid.width, modelo.grid.height))
  for celda in modelo.grid.coord_iter():
    contenido_celda, x, y = celda
    for contenido in contenido_celda:
      if isinstance(contenido, Robot):
        habitacion[x][y] = contenido.estadoR
      else:
        habitacion[x][y] = contenido.estado
  return habitacion
    
#Agente Robot del modelo
class Robot(Agent):
  CAJA_ENCIMA=4
  SIN_CAJA=5
  
  #Inicializador del agente con su constructor
  def __init__(self, id_unico, modelo,estadoR=SIN_CAJA):
    super().__init__(id_unico, modelo)
    self.nueva_posicion = None
    self.movimientos = 0
    self.cajaRecogida=False
    self.estadoR=estadoR
    self.siguiente_estadoR=None

  #En esta función se establecerá el precambio de posición y estado tanto del
  #Robot como del Piso, aquí no se genera ningún cambio real    
  def step(self):
    global exPila
    global contCajas
    global cajas_en_Pila
        
    vecinos = self.model.grid.get_neighbors(
      self.pos,
      moore=False,
      include_center=True)

    for vecino in vecinos:
      if isinstance(vecino, Piso) and vecino.pos == self.pos:
        vecino.siguiente_estado = vecino.estado
        if self.cajaRecogida == False:
          if vecino.siguiente_estado == vecino.CAJA: 
            vecino.siguiente_estado = vecino.NADA
            self.nueva_posicion = self.pos
            self.cajaRecogida=True
            self.siguiente_estadoR=self.CAJA_ENCIMA

          else:
            vecindario2 = self.model.grid.get_neighbors(
              self.pos,
              moore=False,
              include_center=False)
            candidatos=[]
            for vecino2 in vecindario2:
              if not isinstance(vecino2,Robot):
                if isinstance(vecino2,Piso) and vecino2.estado!=vecino2.PILA_LLENA and vecino2.estado!=vecino2.PILA:
                  candidatos.append(vecino2.pos)

            nueva_posicion = self.random.choice(candidatos)
            self.nueva_posicion = nueva_posicion
            self.siguiente_estadoR=self.SIN_CAJA

        else:
          if exPila == False:
            if vecino.siguiente_estado==vecino.NADA and vecino.siguiente_estado != vecino.PILA:
              vecino.siguiente_estado=vecino.PILA
              self.siguiente_estadoR=self.SIN_CAJA
              self.nueva_posicion=self.pos
              exPila=True
              
            else:
              vecindario2 = self.model.grid.get_neighbors(
                self.pos,
                moore=False,
                include_center=False)
              candidatos=[]
              for vecino2 in vecindario2:
                if not isinstance(vecino2,Robot):
                  if (isinstance(vecino2,Piso) and vecino2.estado!=vecino2.PILA_LLENA and vecino2.estado!=vecino2.CAJA):
                    candidatos.append(vecino2.pos)

              nueva_posicion = self.random.choice(candidatos)
              self.nueva_posicion = nueva_posicion
              self.siguiente_estadoR=self.CAJA_ENCIMA

          else:
            if vecino.siguiente_estado==vecino.PILA:
              if contCajas!=5:
                self.nueva_posicion=self.pos
                self.cajaRecogida=False
                self.siguiente_estadoR=self.SIN_CAJA
                contCajas=contCajas+1
                cajas_en_Pila=cajas_en_Pila+1

              else:
                vecino.siguiente_estado=vecino.PILA_LLENA
                self.siguiente_estadoR=self.CAJA_ENCIMA
                contCajas=0
                self.nueva_posicion=self.pos
                exPila=False
            
            else:       
              vecindario2 = self.model.grid.get_neighbors(
                self.pos,
                moore=False,
                include_center=False)
              candidatos=[]
              for vecino2 in vecindario2:
                if not isinstance(vecino2,Robot):
                  if (isinstance(vecino2,Piso) and vecino2.estado!=vecino2.PILA_LLENA and vecino2.estado!=vecino2.CAJA):
                    candidatos.append(vecino2.pos)

              nueva_posicion = self.random.choice(candidatos)
              self.nueva_posicion = nueva_posicion
              self.siguiente_estadoR=self.CAJA_ENCIMA

        break
  
  #Función que hace el cambio real de posiciones y estados de los agentes
  def advance(self):
    global movimientosRobot
        
    vecinos = self.model.grid.get_neighbors(
      self.pos,
      moore=False,
      include_center=True)
        
    for vecino in vecinos:
      if isinstance(vecino, Piso) and vecino.pos == self.pos: 
        vecino.estado = vecino.siguiente_estado
        self.estadoR=self.siguiente_estadoR
        break

    if self.pos != self.nueva_posicion:
      self.movimientos = self.movimientos + 1
      movimientosRobot=movimientosRobot+1
          
    self.model.grid.move_agent(self, self.nueva_posicion)

#Agente Piso del modelo
class Piso(Agent):
    
  PILA_LLENA=3
  PILA=2
  CAJA = 1
  NADA = 0
  
  #Inicializador del agente con su constructor
  def __init__(self, pos, modelo, estado=NADA):
      super().__init__(pos, modelo)
      self.x, self.y = pos
      self.estado = estado
      self.siguiente_estado = None 
      self.exPila=False

#Modelo Habitación
class Habitacion(Model):
  global cajas_en_Pila

  #Inicializador del agente con su constructor
  def __init__(self, m, n, num_agentes, celdas_cajas):
    self.num_agentes = num_agentes
    self.celdas_cajas = celdas_cajas
    self.celdas_limpias = m*n-celdas_cajas
    self.grid = MultiGrid(m, n, False)
    self.schedule = SimultaneousActivation(self)
               
    lista_celdas_vacias = list(self.grid.empties)
    for celdas in range(celdas_cajas):
        celda_vacia = random.choice(lista_celdas_vacias)
        piso = Piso(celda_vacia, self)
        piso.estado = piso.CAJA
        self.grid.place_agent(piso, celda_vacia)
        self.schedule.add(piso)
        lista_celdas_vacias.remove(celda_vacia)

    lista_celdas_vacias = list(self.grid.empties)
    for celdas in lista_celdas_vacias:
        piso = Piso(celdas, self)
        self.grid.place_agent(piso, celdas)
        self.schedule.add(piso)

    for i in range(num_agentes):
        robot = Robot(i, self)
        posicion=self.random.choice(lista_celdas_vacias)
        self.grid.place_agent(robot, posicion)
        self.schedule.add(robot)
        lista_celdas_vacias.remove(posicion)

    self.colectordatos = DataCollector(
        model_reporters={'Habitacion': obtener_habitacion},
        agent_reporters={'Movimientos': lambda a: getattr(a, 'movimientos', None)}
    )
  
  #Se genera el step del agente Robot y se recolectan los datos
  def step(self):
      self.colectordatos.collect(self)
      self.schedule.step()   

  #Si todas las celdas estan vacias o apiladas termina la simulacion
  def todasCajasPilas(self):
    celdas_vacias = 0
    celdas_pilas=0
    celdas_pilas_llenas=0
    for celda in self.grid.coord_iter():
        contenido_celda, x, y = celda
        for contenido in contenido_celda:
            if isinstance(contenido, Piso) and contenido.estado == contenido.NADA:
                celdas_vacias = celdas_vacias + 1
            if isinstance(contenido,Piso) and contenido.estado==contenido.PILA:
                celdas_pilas=celdas_pilas+1
            if isinstance(contenido,Piso) and contenido.estado==contenido.PILA_LLENA:
                celdas_pilas_llenas=celdas_pilas_llenas+1

    self.por_celdas_limpias = (celdas_vacias+celdas_pilas+celdas_pilas_llenas) / (self.grid.width * self.grid.height)
    if self.por_celdas_limpias == 1 and cajas_en_Pila==self.celdas_cajas:
        return True
    else:
        return False

#Precondiciones del modelo
M = 10
N = 10

NUM_AGENTES = 5

CAJAS = 23

TIEMPO_MAXIMO_EJECUCION = 2

start_time = time.time()
tiempo_inicio = str(datetime.timedelta(seconds=TIEMPO_MAXIMO_EJECUCION))
modelo = Habitacion(M, N, NUM_AGENTES, CAJAS)

while((time.time() - start_time) < TIEMPO_MAXIMO_EJECUCION and not modelo.todasCajasPilas()):
    modelo.step()

tiempo_ejecucion = str(datetime.timedelta(seconds=(time.time() - start_time)))
print("Tiempo de ejecución: "+tiempo_ejecucion)
print("Movimientos totales: "+str(movimientosRobot))

todas_habitaciones = modelo.colectordatos.get_model_vars_dataframe()
 
fig, axs = plt.subplots(figsize=(7,7))
axs.set_xticks([])
axs.set_yticks([])
patch = plt.imshow(todas_habitaciones.iloc[0][0], cmap='PuBuGn')
plt.colorbar(patch)
 
def animate(i):
   patch.set_data(todas_habitaciones.iloc[i][0])
     
anim = animation.FuncAnimation(fig, animate, frames=len(todas_habitaciones))

anim